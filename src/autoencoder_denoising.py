# -*- coding: utf-8 -*-
"""autoencoder-denoising.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KuM7OgRWgkHpR2Qc1qzhFuMf_YfN6m-c

# Autoencoder pour débruiter les images

source : https://blog.keras.io/building-autoencoders-in-keras.html

On prends le dataset mnist
et on rajoute du bruit surr les images

On construit un autoencoder avec des couches de convolution avec
- input les images bruitées
- output les images originales

Le modele apprend la representation interne des images et une fois appliqué aux images bruitées est capale d'enlever le bruit
"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

import keras
from keras import layers

"""# Bruiter les images

Sur chaque image on ajoute un bruit gaussien

On peut regler la quantité de bruit avec le parametre : `noise_factor`
"""

from keras.datasets import mnist
import numpy as np

(x_train, _), (x_test, _) = mnist.load_data()

x_train = x_train.astype('float32') / 255.
x_test = x_test.astype('float32') / 255.
x_train = np.reshape(x_train, (len(x_train), 28, 28, 1))
x_test = np.reshape(x_test, (len(x_test), 28, 28, 1))

# rajouter du buit
noise_factor = 0.5
x_train_noisy = x_train + noise_factor * np.random.normal(loc=0.0, scale=1.0, size=x_train.shape)
x_test_noisy = x_test + noise_factor * np.random.normal(loc=0.0, scale=1.0, size=x_test.shape)

# restreindre a l'intervalle [0,1]
x_train_noisy = np.clip(x_train_noisy, 0., 1.)
x_test_noisy = np.clip(x_test_noisy, 0., 1.)

n = 10
plt.figure(figsize=(20, 2))
for i in range(1, n + 1):
    ax = plt.subplot(1, n, i)
    plt.imshow(x_test_noisy[i].reshape(28, 28))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()

"""On reconnais a peine les images

# Le modele

Notez la façon de definir le modele en ajoutant les couches a la variable `x`

Notez aussi la couche [UpSampling2D](https://keras.io/api/layers/reshaping_layers/up_sampling2d/) dans le decoder qui compense la reduction de dimension de la couche Maxpooling2D du encoder
"""

input_img = keras.Input(shape=(28, 28, 1))

x = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(input_img)
x = layers.MaxPooling2D((2, 2), padding='same')(x)
x = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(x)
encoded = layers.MaxPooling2D((2, 2), padding='same')(x)

# At this point the representation is (7, 7, 32)

x = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(encoded)
x = layers.UpSampling2D((2, 2))(x)
x = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(x)
x = layers.UpSampling2D((2, 2))(x)
decoded = layers.Conv2D(1, (3, 3), activation='sigmoid', padding='same')(x)

autoencoder = keras.Model(input_img, decoded)
autoencoder.compile(optimizer='adam', loss='binary_crossentropy')

autoencoder.summary()

autoencoder.fit(x_train_noisy, x_train,
                epochs=50,
                batch_size=128,
                shuffle=True,
                validation_data=(x_test_noisy, x_test))

decoded_imgs = autoencoder.predict(x_test_noisy)

n = 10
plt.figure(figsize=(20, 4))
for i in range(1, n + 1):
    # Display original
    ax = plt.subplot(2, n, i)
    plt.imshow(x_test_noisy[i].reshape(28, 28))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

    # Display reconstruction
    ax = plt.subplot(2, n, i + n)
    plt.imshow(decoded_imgs[i].reshape(28, 28))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()

